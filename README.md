# Java-Lab1

# Отчет по работе: Реализация задач на Java
Бочкарёв Егор ИТ-13,14

## Общее описание
Данный проект представляет собой консольное приложение на Java, которое реализует 20 различных задач, разделенных на 4 категории:
1. Базовые методы (5 задач)
2. Работа с условиями (5 задач)
3. Работа с циклами (5 задач)
4. Работа с массивами (5 задач)

Программа предлагает пользователю выбрать задачу через меню, затем выполняет соответствующую функцию.

## Структура проекта
- `Tasks.java` - главный класс с точкой входа и меню выбора
- `Task.java` - методы проверки и методы заданий

## Детальный анализ методов

### Задание 1

#### 2. Сумма знаков.

**Задание:**

Дана сигнатура метода: public int sumLastNums (int x); Необходимо реализовать метод таким образом, чтобы он возвращал результат сложения двух последних знаков числах, предполагая, что знаков в числе не менее двух.

**Метод решения:**

Что делает:

Возвращает сумму последней и предпоследней цифры числа x (если число имеет ≥2 цифр).

Как работает:
- Условие if (x / 10 > 0) проверяет, есть ли в числе хотя бы 2 цифры (для положительных чисел x >= 10).
- int last = x % 10; — последняя цифра.
- int preLast = (x / 10) % 10; — предпоследняя цифра.
- Возвращает last + preLast.
- Иначе (если число однозначное) печатает ошибку и возвращает 0.

**Пример работы:**
- Вход: 123 → Выход: 2 + 3 = 5
- Вход: 45 → Выход: 4 + 5 = 9
- Вход: 7 → Выход: Ошибка (число должно содержать хотя бы две цифры)

**Код:**
```
 public int sumLastNums(int x) {
        if (x / 10 > 0) {
            int last = x % 10; // последняя цифра
            int preLast = (x / 10) % 10; // предпоследняя цифра
            return last + preLast;
        } else {
            System.out.println("Ошибка: число должно содержать хотя бы две цифры!");
            return 0;
        }

    }
```

#### 4. Есть ли позитив.

**Задание:**

Дана сигнатура метода: public bool isPositive (int x); Необходимо реализовать метод таким образом, чтобы он принимал число x и возвращал true, если оно положительное.  

**Метод решения:**

Что делает:

Проверяет, положительно ли число.

Как работает:

Возвращает x > 0.

**Пример работы:**
- Вход: 5 → Выход: true
- Вход: -3 → Выход: false
- Вход: 0 → Выход: false

**Код:**
```
public boolean isPositive(int x) {
        return x > 0;
    }
```

#### 6. Большая буква.

**Задание:**

Дана сигнатура метода: public bool isUpperCase (char x); Необходимо реализовать метод таким образом, чтобы он принимал символ x и возвращал true, если это большая буква в диапазоне от ‘A’ до ‘Z’.

**Метод решения:**

Что делает:

Проверяет, заглавная ли латинская буква.

Как работает:

Сравнивает x >= 'A' && x <= 'Z'.

**Пример работы:**
- Вход: 'A' → Выход: true
- Вход: 'z' → Выход: false
- Вход: 'Я' → Выход: true (для кириллицы)

**Код:**
```
public boolean isUpperCase(char x) {
        return x >= 'A' && x <= 'Z';
    }
```

#### 8. Делитель.

**Задание:**

Дана сигнатура метода: public bool isDivisor (int a, int b); Необходимо реализовать метод таким образом, чтобы он возвращал true, если любое из принятых чисел делит другое нацело.

**Метод решения:**

Что делает:

Возвращает true, если одно из чисел делится на другое (a|b или b|a), иначе false. Исключает нулевые значения.

Как работает:
- Если a == 0 || b == 0 — сразу возвращает false (чтобы избежать деления на ноль).
- Возвращает (a % b == 0) || (b % a == 0).

**Пример работы:**
- Вход: (10, 5) → Выход: true (10 делится на 5)
- Вход: (7, 14) → Выход: true (14 делится на 7)
- Вход: (3, 7) → Выход: false
- Вход: (0, 5) → Выход: false (исключение деления на ноль)

**Код:**
```
 public boolean isDivisor(int a, int b) {
        if (a == 0 || b == 0) {
            return false; // деление на ноль исключаем
        }
        return (a % b == 0) || (b % a == 0);
    }
```

#### 10. Многократный вызов.

**Задание:**

Дана сигнатура метода: public int lastNumSum(int a, int b) Необходимо реализовать метод таким образом, чтобы он считал сумму цифр двух чисел из разряда единиц. Выполните с его помощью последовательное сложение пяти чисел и результат выведите на экран. Постарайтесь выполнить задачу, используя минимально возможное количество вспомогательных переменных.

**Метод решения:**

Что делает:

Cуммирует последние цифры a и b, затем три раза запрашивает число у пользователя и каждый раз суммирует последнюю цифру нового числа с текущим значением (но при этом печатает полные числа). Возвращает итог.

Как работает:
-Создаёт Scanner scanner = new Scanner(System.in); (внутри метода).
- int total = (a % 10) + (b % 10); — начальная сумма последних цифр.
- Печатает a + " + " + b + " = " + total — Важно: это сообщение может вводить в заблуждение, потому что фактически складываются последние цифры, а не сами a и b.
- В цикле for (int i = 1; i < 4; i++) запрашивает next = scanner.nextInt(); и считает result = (total % 10) + (next % 10);, печатает и присваивает total = result.
- Возвращает total.
 
**Пример работы:**
```
Введите 2 числа: 12, 34
12 + 34 = 6 (2+4)
Введите число: 56
6 + 56 = 12 (6+6)
Введите число: 78
12 + 78 = 20 (2+8)
Введите число: 90
20 + 90 = 10 (0+0)
Итого: 10
```

**Код:**
```
public int lastNumSum(int a, int b) {
        Scanner scanner = new Scanner(System.in);
        int total = (a % 10) + (b % 10);
        System.out.println(a + " + " + b + " = " + total);
        for (int i = 1; i < 4; i++) {
            System.out.println("Введите число: ");
            int next = scanner.nextInt();
            int result = (total % 10) + (next % 10);
            System.out.println(total + " + " + next + " = " + result);
            total = result; // обновляем текущее значение
        }
        return total;
    }
```
***

### Задание 2

#### 2. Безопасное деление.

**Задание:**

Дана сигнатура метода: public double safeDiv (int x, int y); Необходимо реализовать метод таким образом, чтобы он возвращал деление x на y, и при этом гарантировал, что не будет выкинута ошибка деления на 0. При делении на 0 следует вернуть из метода число 0.

**Метод решения:**

Что делает:

Делит x на y, но если y==0, возвращает 0.

Как работает:
- Если y == 0 — return 0;.
- Иначе — return x / y;.

**Пример работы:**
- Вход: (10, 2) → Выход: 5.0
- Вход: (10, 0) → Выход: 0.0
- Вход: (7, 3) → Выход: 2.0 (целочисленное деление)

**Код:**
```
public double safeDiv(int x, int y) {
        if (y == 0) {
            return 0; // если делитель 0, возвращаем 0
        } else {
            return x / y; // иначе выполняем деление
        }
    }
```

#### 4. Строка сравнения.

**Задание:**

Дана сигнатура метода: public String makeDecision (int x, int y); Необходимо реализовать метод таким образом, чтобы он возвращал строку, которая включает два принятых методом числа и корректно выставленный знак операции сравнения (больше, меньше, или равно).

**Метод решения:**

Что делает:

Возвращает строку, показывающую сравнение: "x > y", "x < y" или "x = y".

Как работает:

Простая цепочка if/else if/else.

**Пример работы:**
- Вход: (5, 3) → Выход: "5 > 3"
- Вход: (2, 7) → Выход: "2 < 7"
- Вход: (4, 4) → Выход: "4 = 4"

**Код:**
```
 public String makeDecision(int x, int y) {
        if (x > y) {
            return x + " > " + y;
        } else if (x < y) {
            return x + " < " + y;
        } else {
            return x + " = " + y;
        }
    }
```

#### 6. Тройная сумма.

**Задание:**

Дана сигнатура метода: public bool sum3 (int x, int y, int z); Необходимо реализовать метод таким образом, чтобы он возвращал true, если два любых числа (из трех принятых) можно сложить так, чтобы получить третье.

**Метод решения:**

Что делает:

Проверяет, равна ли сумма каких-то двух чисел третьему (любой комбинации).

Как работает:

if (x+y==z || x+z==y || z+y==x) return true; else return false;.

**Пример работы:**
- Вход: (2, 3, 5) → Выход: true (2+3=5)
- Вход: (1, 4, 2) → Выход: false
- Вход: (5, 5, 10) → Выход: true (5+5=10)

**Код:**
```
 public boolean sum3(int x, int y, int z) {
        if (x + y == z || x + z == y || z + y == x) {
            return true;
        } else {
            return false;
        }
    }
```

#### 8. Возраст.

**Задание:**

Дана сигнатура метода: public String age (int x); Необходимо реализовать метод таким образом, чтобы он возвращал строку, в которой сначала будет число х, а затем одно из слов: год года лет Слово “год” добавляется, если число х заканчивается на 1, кроме числа 11. Слово “года” добавляется, если число х заканчивается на 2, 3 или 4, кроме чисел 12, 13, 14. Слово “лет” добавляется во всех остальных случаях.

**Метод решения:**

Что делает:

Формирует корректное слово для "год/года/лет" на русском в зависимости от числа x.

Как работает:
- Если x % 10 == 1 && x != 11 → "год".
- Иначе если (x % 10 == 2 || 3 || 4) && x != 12,13,14 → "года".
- Иначе → "лет".

**Пример работы:**
- Вход: 1 → Выход: "1 год"
- Вход: 2 → Выход: "2 года"
- Вход: 5 → Выход: "5 лет"
- Вход: 11 → Выход: "11 лет"
- Вход: 21 → Выход: "21 год"

**Код:**
```
public String age(int x) {
        if (x % 10 == 1 && x != 11) {
            return x + " год";
        } else if ((x % 10 == 2 || x % 10 == 3 || x % 10 == 4) && x != 12 && x != 13 && x != 14) {
            return x + " года";
        } else {
            return x + " лет";
        }
    }
```

#### 10. Вывод дней недели.

**Задание:**

Дана сигнатура метода: public void printDays (String x); В качестве параметра метод принимает строку, в которой записано название дня недели. Необходимо реализовать метод таким образом, чтобы он выводил на экран название переданного в него дня и всех последующих до конца недели дней. Если в качестве строки передан не день, то выводится текст “это не день недели”. Первый день понедельник, последний – воскресенье. Вместо if в данной задаче используйте switch. 

**Метод решения:**

Что делает:

Печатать переданного дня недели и всех последующих до конца недели.

Как работает:

switch (x) перечисляет все дни недели с определённого до воскресенья.

**Пример работы:**
- Вход: "понедельник" → Выход: все дни от понедельника до воскресенья
- Вход: "среда" → Выход: среда, четверг, пятница, суббота, воскресенье
- Вход: "неделя" → Выход: "это не день недели"

**Код:**
```
public void printDays(String x) {
        switch (x) {
            case "понедельник":
                System.out.println("понедельник");
            case "вторник":
                System.out.println("вторник");
            case "среда":
                System.out.println("среда");
            case "четверг":
                System.out.println("четверг");
            case "пятница":
                System.out.println("пятница");
            case "суббота":
                System.out.println("суббота");
            case "воскресенье":
                System.out.println("воскресенье");
                break;
            default:
                System.out.println("это не день недели");
                break;
        }
    }
```
***

### Задание 3

#### 2. Числа наоборот.

**Задание:**

Дана сигнатура метода: public String reverseListNums (int x); Необходимо реализовать метод таким образом, чтобы он возвращал строку, в которой будут записаны все числа от x до 0 (включительно).

**Метод решения:**

Что делает:

Формирует строку с числами от x до 0 включительно в порядке убывания, разделённых пробелом.

Как работает:

Инициализирует String s = "", в цикле for (int i = x; i >= 0; i--) s = s + i + " "; и возвращает s.

**Пример работы:**
- Вход: 5 → Выход: "5 4 3 2 1 0"
- Вход: 3 → Выход: "3 2 1 0"
- Вход: 0 → Выход: "0"

**Код:**
```
public String reverseListNums(int x) {
        String s = "";
        for (int i = x; i >= 0; i--) {
            s = s + i + " ";
        }

        return s;
    }
```

#### 4. Степень числа.

**Задание:**

Дана сигнатура метода: public int pow (int x, int y); Необходимо реализовать метод таким образом, чтобы он возвращал результат возведения x в степень y.

**Метод решения:**

Что делает:

Возводит x в целую степень y (умножает x сам на себя y раз).

Как работает:

result = 1; for (int i=0;i<y;i++) result *= x; return result;

**Пример работы:**
- Вход: (2, 3) → Выход: 8
- Вход: (5, 0) → Выход: 1
- Вход: (3, 4) → Выход: 81

**Код:**
```
public int pow(int x, int y) {
        int result = 1;

        for (int i = 0; i < y; i++) {
            result *= x;  // умножаем result на x y раз
        }

        return result;
    }
```

#### 6. Одинаковость.

**Задание:**

Дана сигнатура метода: public bool equalNum (int x); Необходимо реализовать метод таким образом, чтобы он возвращал true, если все знаки числа одинаковы, и false в ином случае.

**Метод решения:**

Что делает:

Проверяет, все ли цифры числа x одинаковы (например, 111 → true, 121 → false).

Как работает:
- int lastDigit = x % 10; — сохраняет последнюю цифру.
- x /= 10; — убирает последнюю цифру.
- Пока x > 0: currentDigit = x % 10; if (currentDigit != lastDigit) return false; x /= 10;
- Если цикл завершился — возвращает true.

**Пример работы:**
- Вход: 111 → Выход: true
- Вход: 123 → Выход: false
- Вход: 9999 → Выход: true
- Вход: 10 → Выход: false

**Код:**
```
public boolean equalNum(int x) {
        int lastDigit = x % 10;
        x /= 10;


        while (x > 0) {
            int currentDigit = x % 10;
            if (currentDigit != lastDigit) {
                return false;
            }
            x /= 10;
        }

        return true;
    }
```

#### 8. Левый треугольник.

**Задание:**

Дана сигнатура метода: public void leftTriangle (int x); Необходимо реализовать метод таким образом, чтобы он выводил на экран треугольник из символов ‘*’ у которого х символов в высоту, а количество символов в ряду совпадает с номером строки.

**Метод решения:**

Что делает:

Печатает левосторонний треугольник из * высоты x.

Как работает:

Для i от 1 до x добавляет * к строке s и печатает её (так строки растут: "*", "**", ...).

**Пример работы:**
```
Вход: 3
*
**
***

Вход: 5
*
**
***
****
*****
```

**Код:**
```
public void leftTriangle(int x) {
        String s = "";
        for (int i = 1; i <= x; i++) {
            s = s + "*";
            System.out.println(s);
        }
    }
```

#### 10. Угадайка.

**Задание:**

Дана сигнатура метода: public void guessGame()  Необходимо реализовать метод таким образом, чтобы он генерировал случайное число от 0 до 9, далее считывал с консоли введенное пользователем число и выводил, угадал ли пользователь то, что было загадано, или нет. Метод запускается до тех пор, пока пользователь не угадает число. После этого выведите на экран количество попыток, которое потребовалось пользователю, чтобы угадать число.

**Метод решения:**

Что делает:

Простая игра: загадать число 0–9 и дать игроку пытаться угадать пока не угадает; считает число попыток.

Как работает:
- Random random = new Random();
- int rand = random.nextInt(0, 10); — случайное число в [0,9]. (Этот перегруженный метод доступен в Java 17+. Для старых версий используйте random.nextInt(10).)
- Создаёт Scanner scanner = new Scanner(System.in); и читает первое number = scanner.nextInt();.
- attempts = 1;
- В бесконечном цикле сравнивает rand с number. Если равны — печатает успех и количество попыток и break. Иначе — просит следующий ввод, увеличивает attempts.

**Пример работы:**
```
Введите число от 0-9: 5
Вы не угадали, введите число от 0 до 9: 3
Вы не угадали, введите число от 0 до 9: 7
Вы угадали!
Вы отгадали число за 3 попытки
```

**Код:**
```
public void guessGame() {
        Random random = new Random();
        Scanner scanner = new Scanner(System.in);
        int rand = random.nextInt(0, 10);

        System.out.println("Введите число от 0-9:");
        int number = scanner.nextInt();

        int attempts = 1;

        while (true) {
            if (rand == number) {
                System.out.println("Вы угадали!");
                System.out.println("Вы отгадали число за " + attempts + " попытки");
                break;
            } else {
                System.out.println("Вы не угадали, введите число от 0 до 9:");
                ++attempts;
                number = scanner.nextInt();
            }
        }
    }
```
***

### Задание 4

#### 2. Поиск последнего значения.

**Задание:**

Дана сигнатура метода: public int findLast (int[] arr, int x); Необходимо реализовать метод таким образом, чтобы он возвращал индекс последнего вхождения числа x в массив arr. Если число не входит в массив – возвращается -1.

**Метод решения:**

Что делает:

Возвращает индекс последнего вхождения x в arr, или -1, если нет.

Как работает:

Проходит массив с конца for (int i = arr.length-1; i>=0; i--) if (arr[i]==x) return i; затем return -1.

**Пример работы:**
- Вход: ([1, 2, 3, 2, 4], 2) → Выход: 3 (индекс)
- Вход: ([5, 6, 7], 8) → Выход: -1 (не найдено)
- Вход: ([], 5) → Выход: -1

**Код:**
```
public int findLast(int[] arr, int x) {
        // Проходим массив с конца
        for (int i = arr.length - 1; i >= 0; i--) {
            if (arr[i] == x) {
                return i;
            }
        }

        return -1;
    }
```

#### 4. Добавление в массив.

**Задание:**

Дана сигнатура метода: public int[]add (int[] arr, int x, int pos); Необходимо реализовать метод таким образом, чтобы он возвращал новый массив, который будет содержать все элементы массива arr, однако в позицию pos будет вставлено значение x.

**Метод решения:**

Что делает:

Вставляет значение x в позицию pos массива arr и возвращает новый массив.

Как работает:
- Создаёт newArr длиной на 1 больше.
- Копирует элементы for (int i = 0; i < pos; i++) newArr[i] = arr[i];
- newArr[pos] = x;
- Копирует оставшиеся элементы со сдвигом for (int i = pos; i < arr.length; i++) newArr[i + 1] = arr[i];
- Возвращает newArr.

**Пример работы:**
- Вход: ([1, 2, 3], 9, 1) → Выход: [1, 9, 2, 3]
- Вход: ([10, 20], 5, 0) → Выход: [5, 10, 20]
- Вход: ([], 7, 0) → Выход: [7]

**Код:**
```
 public int[] add(int[] arr, int x, int pos) {
        int[] newArr = new int[arr.length + 1];
        for (int i = 0; i < pos; i++) {
            newArr[i] = arr[i];
        }

        newArr[pos] = x;

        for (int i = pos; i < arr.length; i++) {
            newArr[i + 1] = arr[i];
        }
        return newArr;
    }
```

#### 6. Реверс.

**Задание:**

Дана сигнатура метода: public void reverse (int[] arr); Необходимо реализовать метод таким образом, чтобы он изменял массив arr. После проведенных изменений массив должен быть записан задом-наперед.

**Метод решения:**

Что делает:

Разворачивает массив arr на месте (in-place). Затем печатает результат.

Как работает:
- Проходит первые arr.length / 2 элементов, меняет arr[i] и arr[arr.length-1-i] местами с помощью временной переменной New.
- После перестановок печатает Результат: и все элементы массива по порядку.

**Пример работы:**
- Вход: [1, 2, 3, 4] → Выход: [4, 3, 2, 1]
- Вход: [5] → Выход: [5]
- Вход: [] → Выход: []

**Код:**
```
 public void reverse(int[] arr) {
        for (int i = 0; i < arr.length / 2; i++) {
            int New = arr[i];
            arr[i] = arr[arr.length - 1 - i];
            arr[arr.length - 1 - i] = New;
        }

        System.out.println("Результат: ");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + " ");
        }
    }
```

#### 8. Объединение.

**Задание:**

Дана сигнатура метода: public int[] concat (int[] arr1,int[] arr2); Необходимо реализовать метод таким образом, чтобы он возвращал новый массив, в котором сначала идут элементы первого массива (arr1), а затем второго (arr2).

**Метод решения:**

Что делает:

Возвращает новый массив, содержащий сначала arr1, затем arr2.

Как работает:

Создаёт newArr длиной arr1.length + arr2.length, копирует элементы arr1, затем arr2 с индексом смещения arr1.length + i.

**Пример работы:**
- Вход: ([1, 2], [3, 4]) → Выход: [1, 2, 3, 4]
- Вход: ([], [5, 6]) → Выход: [5, 6]
- Вход: ([7, 8], []) → Выход: [7, 8]

**Код:**
```
public int[] concat(int[] arr1, int[] arr2) {
        int[] newArr = new int[arr1.length + arr2.length];

        for (int i = 0; i < arr1.length; i++) {
            newArr[i] = arr1[i];
        }

        for (int i = 0; i < arr2.length; i++) {
            newArr[arr1.length + i] = arr2[i];
        }

        return newArr;
    }
```

#### 10. Удалить негатив.

**Задание:**

Дана сигнатура метода: public int[] deleteNegative (int[] arr); Необходимо реализовать метод таким образом, чтобы он возвращал новый массив, в котором записаны все элементы массива arr кроме отрицательных.

**Метод решения:**

Что делает:

Возвращает новый массив, содержащий только элементы >= 0 (удаляет отрицательные).

Как работает:
- Считает countPositive (количество num >= 0).
- Создаёт newArr длиной countPositive.
- Вторым проходом копирует все num >= 0 в newArr.
- Возвращает newArr.

**Пример работы:**
- Вход: [1, -2, 3, -4, 5] → Выход: [1, 3, 5]
- Вход: [-1, -2, -3] → Выход: []
- Вход: [4, 5, 6] → Выход: [4, 5, 6]

**Код:**
```
public int[] deleteNegative(int[] arr) {
        int countPositive = 0;
        for (int num : arr) {
            if (num >= 0) {
                countPositive++;
            }
        }

        int[] newArr = new int[countPositive];
        int index = 0;

        for (int num : arr) {
            if (num >= 0) {
                newArr[index++] = num;
            }
        }

        return newArr;
    }
}
```
***

## Вспомогательные методы

+ `public int readInt(Scanner scanner)`

Что делает:

Читает из Scanner целое число, пока пользователь не введёт корректное значение.

Как работает (пошагово):
- Заходит в бесконечный цикл while (true).
- Печатает приглашение "Введите целое число: ".
- Проверяет scanner.hasNextInt() — есть ли следующий токен, который можно распарсить как int.
- Если true: читает int num = scanner.nextInt(); и возвращает num.
- Иначе: печатает сообщение об ошибке и вызывает scanner.next() — чтобы "съесть" неверный токен (иначе hasNextInt() будет снова false и цикл застрянет).

Примеры:

При вводе 42 вернёт 42; при вводе abc — попросит ввести ещё раз.

Код:
```
public int readInt(Scanner scanner) {
        while (true) {
            System.out.print("Введите целое число: ");
            if (scanner.hasNextInt()) {
                int num = scanner.nextInt();
                return num;
            } else {
                System.out.println("Ошибка: введите целое число!");
                scanner.next(); // очищаем неверный ввод
            }
        }
    }
```

+ `public char readChar(Scanner scanner)`

Что делает:

Читает из Scanner строку и ожидает ровно один буквенный символ; повторяет запрос, если ввод некорректен.

Как работает:
- Бесконечный цикл. Печатает приглашение.
- Читает строку String input = scanner.nextLine();.
- Проверяет input.length() == 1 && Character.isLetter(input.charAt(0)).
- Если верно — возвращает символ input.charAt(0), иначе — выводит ошибку и повторяет.

Примеры:

Ввод A → 'A'; ввод ab или 1 → ошибка.

Код:
```
public char readChar(Scanner scanner) {
        while (true) {
            System.out.print("Введите одну букву: ");
            String input = scanner.nextLine();


            if (input.length() == 1 && Character.isLetter(input.charAt(0))) {
                return input.charAt(0);
            } else {
                System.out.println("Ошибка: нужно ввести одну букву!");
            }
        }
    }
```

+ `public void printArray(int[] arr)`

Что делает:

Печатает элементы массива в одну строку, через пробел, затем перевод строки.
Как работает:

Простой for-each — для каждого num печатает num + " ", потом System.out.println();.

Код:
```
public void printArray(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
        System.out.println();
    }
```
